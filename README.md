## Assembler and Simulator for 16-Bit RISC ISA
A 16-Bit Assembler and Simulator using Python.
Program takes Assembly code as Input and gives Machine Code
as output. It also detects error present in the Assembly Code.
It also simulates the given Machine code and indicate the state
of CPU Registers.

## Steps to RunðŸ’»
- First Clone this Repository
- Then to Run ISA Assembler run assembler.py
- And to Run Simulator run simulator.py

## Description of the ISA and Project ðŸ“‘
- See the ISA Description in given Problem Description File.
- The project aim is also available there
- Description and requirement of simular and assembler is present there as well
- Access the description file [`here`](https://drive.google.com/file/d/1gyGuH_jLR3Oz5mUnMYha3JkbDgAnHcaP/view?usp=sharing) as well

## Requirements and description of Assembler
The assembler should be capable of:
1. Handling all supported instructions
2. Handling labels
3. Handling variables
4. Making sure that any illegal instruction (any instruction (or instruction usage) which is not
supported) results in a syntax error. In particular you must handle:  
  a. Typos in instruction name or register name  
  b. Use of undefined variables  
  c. Use of undefined labels  
  d. Illegal use of FLAGS register  
  e. Illegal Immediate values (less than 0 or more than 255)  
  f. Misuse of labels as variables or vice-versa  
  g. Variables not declared at the beginning  

Input/Output format:
- The assembler must read the assembly program as an input on stdin.
- The assembler must generate the binary (if there are no errors) as an output text file
(stdout).
- The assembler must generate the error notifications along with line number on which the
error was encountered (if there are errors) as the output text file (stdout). In case of
multiple errors, the assembler may print any one of the errors.

Example Test Case
var X  
mov R1 $10  
mov R2 $100  
mul R3 R1 R2  
st R3 X  
hlt
An extra blank line is needed.

The above program will be converted into the following machine code  
0001000100001010  
0001001001100100  
0011000011001010  
0010101100000101  
1001100000000000 

If there is no error.
![image](https://user-images.githubusercontent.com/76804249/189993791-95a5e58d-c2ee-4f24-a60a-324ba0cfd49e.png)

Suppose we don't use hlt in above we get an error

![image](https://user-images.githubusercontent.com/76804249/189993998-e278be75-fb42-4ac0-bed7-31dd815cddc2.png)


## Requirements and description of Simulator

You need to write a simulator for the given ISA. The input to the simulator is a binary file (the
format is the same as the format of the binary file generated by the assembler in Q1). The
simulator should load the binary in the system memory at the beginning, and then start
executing the code at address 0. The code is executed until hlt is reached.

`Input/Output`

After execution of each instruction, the simulator should output one line containing an 8 bit number denoting the
program counter.  
This should be followed by 8 space separated 16 bit binary numbers denoting
the values of the registers (R0, R1, â€¦ R6 and FLAGS).
<PC (8 bits)><space><R0 (16 bits)><space>...<R6 (16 bits)><space><FLAGS (16 bits)>.
The output must be written to stdout.  
After the program is halted, print the memory dump of the whole memory. This should be 256 lines, each
having a 16 bit value
<16 bit data>
<16 bit data>
â€¦..
<16 bit data>
Your simulator must have the following distinct components:
1. Memory (MEM): MEM takes in an 8 bit address and returns a 16 bit value as the data.
The MEM stores 512bytes, initialized to 0s.
2. Program Counter (PC): The PC is an 8 bit register which points to the current instruction.
3. Register File (RF): The RF takes in the register name (R0, R1, â€¦ R6 or FLAGS) and
returns the value stored at that register.
4. Execution Engine (EE): The EE takes the address of the instruction from the PC, uses it
to get the stored instruction from MEM, and executes the instruction by updating the RF
and PC.
The simulator should follow roughly the following pseudocode:
  ```
initialize(MEM); // Load memory from stdin
PC = 0; // Start from the first instruction
halted = false;
white(not halted)
{
Instruction = MEM.getData(PC); // Get current instruction
halted, new_PC = EE.execute(Instruction); // Update RF compute new_PC
PC.dump(); // Print PC
RF.dump(); // Print RF state
PC.update(new_PC); // Update PC
}
MEM.dump() // Print memory state
  
```


